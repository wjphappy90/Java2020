#MongDB优化

​	MongoDB 是高性能数据，但是在使用的过程中，大家偶尔还会碰到一些性能问题。MongoDB和其它关系型数据库相比，例如 SQL Server 、MySQL 、Oracle 相比来说，相对较新，很多人对其不是很熟悉，所以很多开发、DBA往往是注重功能的实现，而忽视了性能的要求。其实，MongoDB和 SQL Server 、MySQL 、Oracle 一样，一个 数据库对象的设计调整、索引的创建、语句的优化，都会对性能产生巨大的影响。

为充分挖掘MongoDB性能，简单列举以下Mongodb优化方式：

1. 文档中的_id键推荐使用默认值，禁止向_id中保存自定义的值。
  ​解读： MongoDB文档中都会有一个“_id”键，默认是个ObjectID对象（标识符中包含时间戳、机器ID、进程ID和计数器）。MongoDB在指定_id与不指定_id插入时 速度相差很大，指定_id会减慢插入的速率。
  ​

2. 推荐使用短字段名。
  解读：与关系型数据库不同，MongoDB集合中的每一个文档都需要存储字段名，长字段名会需要更多的存储空间。

  ​

3. MongoDB索引可以提高文档的查询、更新、删除、排序操作，所以结合业务需求，适当创建索引。

   ​

4. 每个索引都会占用一些空间，并且导致插入操作的资源消耗，因此，建议每个集合的索引数尽量控制在5个以内。

   ​

5. 对于包含多个键的查询，创建包含这些键的复合索引是个不错的解决方案。复合索引的键值顺序很重要，理解索引最左前缀原则。
  解读：例如在test集合上创建组合索引{a:1,b:1,c:1}。执行以下7个查询语句：
  db.test.find({a:”hello”}) // 1
  db.test.find({b:”sogo”, a:”hello”}) // 2
  db.test.find({a:”hello”,b:”sogo”, c:”666”}) // 3
  db.test.find({c:”666”, a:”hello”}) // 4
  db.test.find({b:”sogo”, c:”666”}) // 5
  db.test.find({b:”sogo” }) // 6
  db.test.find({c:”666”}) // 7
  以上查询语句可能走索引的是1、2、3、4
  查询应包含最左索引字段，以索引创建顺序为准，与查询字段顺序无关。
  最少索引覆盖最多查询。

  ​

6. TTL 索引（time-to-live index，具有生命周期的索引），使用TTL索引可以将超时时间的文档老化，一个文档到达老化的程度之后就会被删除。
  解读：创建TTL的索引必须是日期类型。TTL索引是一种单字段索引，不能是复合索引。TTL删除文档后台线程每60s移除失效文档。不支持定长集合。

  ​

7. 需要在集合中某字段创建索引，但集合中大量的文档不包含此键值时，建议创建稀疏索引。
  解读：索引默认是密集型的，这意味着，即使文档的索引字段缺失，在索引中也存在着一个对应关系。在稀疏索引中，只有包含了索引键值的文档才会出现。

  ​

8. 创建文本索引时字段指定text，而不是1或者-1。每个集合只有一个文本索引，但是它可以为任意多个字段建立索引。
  解读：文本搜索速度快很多，推荐使用文本索引替代对集合文档的多字段的低效查询。

  ​

9. 使用findOne在数据库中查询匹配多个项目，它就会在自然排序文件集合中返回第一个项目。如果需要返回多个文档，则使用find方法。

   ​

10. 如果查询无需返回整个文档或只是用来判断键值是否存在，可以通过投影（映射）来限制返回字段，减少网络流量和客户端的内存使用。
  解读：既可以通过设置{key:1}来显式指定返回的字段，也可以设置{key:0}指定需要排除的字段。

  ​

11. 除了前缀样式查询，正则表达式查询不能使用索引，执行的时间比大多数选择器更长，应节制性地使用它们。

    ​

12. 批量插入（batchInsert）可以减少数据向服务器的提交次数，提高性能。但是批量提交的BSON Size不超过48MB。

    ​

13. 禁止一次取出太多的数据进行排序，MongoDB目前支持对32M以内的结果集进行排序。如果需要排序，请尽量限制结果集中的数据量。